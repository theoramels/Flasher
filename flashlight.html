<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Morse Flashlight</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #0a0a0f; color: #e0e0e0;
    min-height: 100vh; display: flex; flex-direction: column;
  }
  header { text-align: center; padding: 24px 16px 12px; }
  header h1 { font-size: 1.6rem; letter-spacing: 2px; color: #fff; }
  header p { font-size: 0.8rem; color: #888; margin-top: 4px; }

  .tabs {
    display: flex; margin: 0 16px;
    border-radius: 12px; overflow: hidden; background: #1a1a2e;
  }
  .tab {
    flex: 1; padding: 12px; text-align: center; cursor: pointer;
    font-size: 0.95rem; font-weight: 600; color: #888; transition: all 0.2s;
    border: none; background: transparent;
  }
  .tab.active { background: #4f8ef7; color: #fff; border-radius: 12px; }

  .panel { display: none; padding: 20px 16px; flex-direction: column; gap: 16px; }
  .panel.active { display: flex; }

  textarea {
    width: 100%; padding: 14px; border-radius: 12px;
    background: #1a1a2e; border: 1px solid #2a2a4a;
    color: #fff; font-size: 1rem; resize: none; height: 100px; outline: none;
  }
  textarea:focus { border-color: #4f8ef7; }

  .morse-display {
    background: #1a1a2e; border-radius: 12px; padding: 14px;
    font-family: monospace; font-size: 1.1rem; letter-spacing: 3px;
    color: #4f8ef7; min-height: 50px; word-break: break-all; line-height: 1.8;
  }

  .speed-row { display: flex; align-items: center; gap: 12px; }
  .speed-row label { font-size: 0.85rem; color: #888; white-space: nowrap; }
  input[type=range] { flex: 1; accent-color: #4f8ef7; }

  button.main-btn {
    padding: 16px; border-radius: 14px; border: none;
    font-size: 1.1rem; font-weight: 700; cursor: pointer;
    transition: all 0.15s; width: 100%;
  }
  .btn-blue  { background: #4f8ef7; color: #fff; }
  .btn-blue:active { background: #2d6ed6; }
  .btn-red   { background: #e74c3c; color: #fff; }
  .btn-green { background: #2ecc71; color: #fff; }
  .btn-green.recording { background: #e74c3c; }
  .btn-orange { background: #e67e22; color: #fff; }
  button:disabled { background: #2a2a4a !important; color: #555 !important; cursor: default; }

  .status-dot {
    width: 12px; height: 12px; border-radius: 50%;
    background: #333; display: inline-block; margin-right: 8px; transition: background 0.1s;
  }
  .status-bar {
    display: flex; align-items: center; padding: 10px 14px;
    background: #1a1a2e; border-radius: 10px; font-size: 0.9rem;
  }

  #receive-output {
    background: #1a1a2e; border-radius: 12px; padding: 14px;
    min-height: 80px; font-size: 1.1rem; color: #2ecc71;
    word-break: break-word; line-height: 1.7;
  }
  #receive-morse {
    background: #1a1a2e; border-radius: 12px; padding: 14px;
    font-family: monospace; font-size: 1rem; color: #888;
    min-height: 40px; word-break: break-all; letter-spacing: 2px;
  }

  .calib-box {
    background: #1a1a2e; border: 1px solid #2a2a4a;
    border-radius: 12px; padding: 14px; font-size: 0.85rem;
    line-height: 1.8; color: #aaa;
  }
  .calib-box strong { color: #fff; }
  .calib-value { color: #4f8ef7; font-family: monospace; font-size: 1rem; }
  .calib-ok    { color: #2ecc71; }
  .calib-warn  { color: #e67e22; }

  .hint { font-size: 0.78rem; color: #555; text-align: center; line-height: 1.5; }
  canvas#camCanvas { display: none; }
  .light-meter { height: 8px; border-radius: 4px; background: #1a1a2e; overflow: hidden; }
  .light-meter-fill { height: 100%; width: 0%; background: #2ecc71; transition: width 0.05s; border-radius: 4px; }
  .section-label { font-size: 0.75rem; color: #555; text-transform: uppercase; letter-spacing: 1px; margin-bottom: -8px; }
  .device-badge {
    text-align: center; font-size: 0.75rem; padding: 4px 10px;
    background: #1a1a2e; border-radius: 20px; color: #555; margin: 0 auto; width: fit-content;
  }
  .row { display: flex; gap: 10px; }
  .row .main-btn { flex: 1; }
</style>
</head>
<body>
<header>
  <h1>âš¡ MORSE LIGHT</h1>
  <p>Flashlight Morse Code Communicator <br> Now with Calibration!</p>
</header>
<div class="device-badge" id="deviceBadge">Detecting...</div>
<br>
<div class="tabs">
  <button class="tab active" onclick="switchTab('send')">ðŸ“¡ Transmit</button>
  <button class="tab" onclick="switchTab('receive')">ðŸ“· Receive</button>
  <button class="tab" onclick="switchTab('ref')">ðŸ“– Reference</button>
</div>

<!-- â•â• TRANSMIT â•â• -->
<div id="panel-send" class="panel active">
  <p class="section-label">Message</p>
  <textarea id="msgInput" placeholder="Type your message here..." oninput="updateMorse()"></textarea>

  <p class="section-label">Morse Preview</p>
  <div class="morse-display" id="morsePreview">â€”</div>

  <div class="speed-row">
    <label>Speed: <span id="speedLabel">Medium</span></label>
    <input type="range" id="speedSlider" min="1" max="5" value="3" oninput="updateSpeedLabel()">
  </div>

  <div class="status-bar">
    <span class="status-dot" id="flashDot"></span>
    <span id="sendStatus">Ready</span>
  </div>

  <div class="row">
    <button class="main-btn btn-orange" id="calibBtn" onclick="startCalibTransmit()">ðŸ“¶ Send Calibration</button>
    <button class="main-btn btn-blue"   id="sendBtn"  onclick="startTransmit()">âš¡ Transmit</button>
  </div>
  <button class="main-btn btn-red" id="stopBtn" onclick="stopTransmit()" style="display:none">â›” Stop</button>

  <p class="hint">Step 1: Both phones point at each other. Tap <strong>Send Calibration</strong> while the other phone taps <strong>Run Calibration</strong>. Then transmit your message.</p>
</div>

<!-- â•â• RECEIVE â•â• -->
<div id="panel-receive" class="panel">
  <div class="status-bar">
    <span class="status-dot" id="rxDot"></span>
    <span id="rxStatus">Press Start to begin</span>
  </div>
  <div class="light-meter"><div class="light-meter-fill" id="lightMeter"></div></div>

  <!-- Calibration result display -->
  <div class="calib-box" id="calibResult">
    <strong>Timing Calibration</strong><br>
    Dot unit: <span class="calib-value" id="cr-dot">not set</span><br>
    Dash threshold: <span class="calib-value" id="cr-dash">not set</span><br>
    Gap threshold: <span class="calib-value" id="cr-gap">not set</span><br>
    Status: <span id="cr-status" class="calib-warn">âš  Run calibration before receiving</span>
  </div>

  <div class="row">
    <button class="main-btn btn-orange" id="runCalibBtn" onclick="toggleCalib()">ðŸ“¶ Run Calibration</button>
    <button class="main-btn btn-green"  id="rxBtn"       onclick="toggleReceive()">ðŸ“· Start Receiving</button>
  </div>
  <button class="main-btn btn-red" onclick="clearReceived()">ðŸ—‘ Clear</button>

  <p class="section-label">Decoded Morse</p>
  <div id="receive-morse">â€”</div>
  <p class="section-label">Decoded Text</p>
  <div id="receive-output">â€”</div>

  <canvas id="camCanvas"></canvas>
  <video id="camVideo" autoplay playsinline muted style="display:none"></video>

  <p class="hint">Point this phone's camera directly at the other phone's flashlight. Works best in a dim room ~1â€“3 feet apart.</p>
</div>

<!-- â•â• REFERENCE â•â• -->
<div id="panel-ref" class="panel">
  <p style="color:#888;font-size:0.9rem;">International Morse Code:</p>
  <div id="refGrid" style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-family:monospace;"></div>
</div>

<script>
// â”€â”€ Morse tables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MORSE = {
  'A':'.-','B':'-...','C':'-.-.','D':'-..','E':'.','F':'..-.','G':'--.','H':'....','I':'..','J':'.---',
  'K':'-.-','L':'.-..','M':'--','N':'-.','O':'---','P':'.--.','Q':'--.-','R':'.-.','S':'...','T':'-',
  'U':'..-','V':'...-','W':'.--','X':'-..-','Y':'-.--','Z':'--..',
  '0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....','6':'-....','7':'--...','8':'---..','9':'----.',
  '.':'.-.-.-',',':'--..--','?':'..--..','!':'-.-.--','/':'-..-.','@':'.--.-.'
};
const MORSE_REV = Object.fromEntries(Object.entries(MORSE).map(([k,v])=>[v,k]));

// â”€â”€ Device detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('deviceBadge').textContent =
  /iPad|iPhone|iPod/.test(navigator.userAgent) ? 'ðŸŽ iOS Device' :
  /Android/.test(navigator.userAgent)          ? 'ðŸ¤– Android Device' : 'ðŸ’» Desktop Browser';

// â”€â”€ Reference grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const refGrid = document.getElementById('refGrid');
Object.entries(MORSE).forEach(([ch,code]) => {
  const el = document.createElement('div');
  el.style.cssText = 'background:#1a1a2e;padding:8px 10px;border-radius:8px;display:flex;justify-content:space-between;';
  el.innerHTML = `<span style="color:#fff;font-weight:700">${ch}</span><span style="color:#4f8ef7">${code}</span>`;
  refGrid.appendChild(el);
});

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function textToMorse(txt) {
  return txt.toUpperCase().split('').map(c => c === ' ' ? '/' : (MORSE[c] || '')).filter(x=>x).join(' ');
}
function updateMorse() {
  document.getElementById('morsePreview').textContent = textToMorse(document.getElementById('msgInput').value) || 'â€”';
}
const speedLabels = ['Very Slow','Slow','Medium','Fast','Very Fast'];
const speedDots   = [300, 200, 130, 80, 50];
function updateSpeedLabel() {
  document.getElementById('speedLabel').textContent = speedLabels[+document.getElementById('speedSlider').value-1];
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// â”€â”€ Wake Lock â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let wakeLock = null;
async function requestWakeLock() {
  if ('wakeLock' in navigator) try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
}
function releaseWakeLock() { if (wakeLock) { wakeLock.release(); wakeLock = null; } }

// â”€â”€ Torch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function getTorchTrack() {
  for (const c of [
    { video: { facingMode: { exact: 'environment' } } },
    { video: { facingMode: 'environment' } },
    { video: true }
  ]) {
    try {
      const stream = await navigator.mediaDevices.getUserMedia(c);
      const track  = stream.getVideoTracks()[0];
      try { await track.applyConstraints({ advanced: [{ torch: false }] }); return { stream, track }; }
      catch(e) { stream.getTracks().forEach(t=>t.stop()); }
    } catch(e) {}
  }
  return null;
}
async function setTorch(track, on) {
  try { await track.applyConstraints({ advanced: [{ torch: on }] }); } catch(e){}
}

// â”€â”€ Calibration sequence definition â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Pattern: 4 dots, pause, 4 dashes, pause, ".-" x3  (known dot/dash/gap mix)
// This gives the receiver clear examples of dot durations, dash durations, and char gaps.
function buildCalibPattern(dot) {
  const dash = dot * 3, sym = dot, chr = dot * 3;
  const seq = [];
  // 4 dots
  for (let i=0;i<4;i++) { seq.push([true,dot]); if(i<3) seq.push([false,sym]); }
  seq.push([false, chr]);
  // 4 dashes
  for (let i=0;i<4;i++) { seq.push([true,dash]); if(i<3) seq.push([false,sym]); }
  seq.push([false, chr]);
  // ".-" repeated 3 times (known letter A)
  for (let i=0;i<3;i++) {
    seq.push([true,dot]);  seq.push([false,sym]);
    seq.push([true,dash]); if(i<2) seq.push([false,chr]);
  }
  return seq;
}

// â”€â”€ Transmit helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let stopRequested = false;
let txTrack = null, txStream = null;

async function acquireTorch() {
  const result = await getTorchTrack();
  if (!result) {
    document.getElementById('sendStatus').textContent = 'âš ï¸ Torch not available.';
    resetSendUI(); releaseWakeLock(); return null;
  }
  txStream = result.stream; txTrack = result.track;
  return result.track;
}

async function runFlashSequence(track, seq, statusEl) {
  for (const [on, dur] of seq) {
    if (stopRequested) break;
    await setTorch(track, on);
    if (on) document.getElementById('flashDot').classList.add('on');
    else    document.getElementById('flashDot').classList.remove('on');
    await sleep(dur);
  }
  await setTorch(track, false);
  document.getElementById('flashDot').classList.remove('on');
}

async function startCalibTransmit() {
  document.getElementById('sendStatus').textContent = 'Sending calibration...';
  document.getElementById('calibBtn').disabled = true;
  document.getElementById('sendBtn').disabled  = true;
  document.getElementById('stopBtn').style.display = 'block';
  stopRequested = false;
  await requestWakeLock();

  const track = await acquireTorch();
  if (!track) { document.getElementById('calibBtn').disabled = false; document.getElementById('sendBtn').disabled = false; return; }

  const dot = speedDots[+document.getElementById('speedSlider').value-1];
  // Send calibration pattern twice so receiver has plenty of data
  for (let r=0; r<2 && !stopRequested; r++) {
    document.getElementById('sendStatus').textContent = `Calibration pass ${r+1}/2...`;
    await runFlashSequence(track, buildCalibPattern(dot), null);
    await sleep(dot * 7);
  }

  txStream.getTracks().forEach(t=>t.stop()); txStream=null; txTrack=null;
  releaseWakeLock();
  document.getElementById('sendStatus').textContent = stopRequested ? 'Stopped.' : 'âœ… Calibration sent!';
  resetSendUI();
}

async function startTransmit() {
  const txt = document.getElementById('msgInput').value.trim();
  if (!txt) { alert('Please enter a message.'); return; }
  const morse = textToMorse(txt);

  document.getElementById('sendBtn').disabled  = true;
  document.getElementById('calibBtn').disabled = true;
  document.getElementById('stopBtn').style.display = 'block';
  document.getElementById('sendStatus').textContent = 'Requesting torch...';
  stopRequested = false;
  await requestWakeLock();

  const track = await acquireTorch();
  if (!track) return;

  const dot  = speedDots[+document.getElementById('speedSlider').value-1];
  const dash = dot*3, symGap = dot, charGap = dot*3, wordGap = dot*7;
  const flash = async(dur) => {
    await setTorch(track,true);  document.getElementById('flashDot').classList.add('on');
    await sleep(dur);
    await setTorch(track,false); document.getElementById('flashDot').classList.remove('on');
  };

  const tokens = morse.split(' ');
  for (let t=0; t<tokens.length && !stopRequested; t++) {
    const token = tokens[t];
    if (token==='/') { await sleep(wordGap-charGap); continue; }
    document.getElementById('sendStatus').textContent = `Sending: ${token}`;
    for (let s=0; s<token.length && !stopRequested; s++) {
      await flash(token[s]==='.'?dot:dash);
      if (s<token.length-1) await sleep(symGap);
    }
    if (t<tokens.length-1 && tokens[t+1]!=='/') await sleep(charGap);
  }

  txStream.getTracks().forEach(t=>t.stop()); txStream=null; txTrack=null;
  releaseWakeLock();
  document.getElementById('sendStatus').textContent = stopRequested ? 'Stopped.' : 'âœ… Done!';
  resetSendUI();
}

function stopTransmit() { stopRequested = true; }
function resetSendUI() {
  document.getElementById('sendBtn').disabled  = false;
  document.getElementById('calibBtn').disabled = false;
  document.getElementById('stopBtn').style.display = 'none';
}

// â”€â”€ Receive & Calibration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const video  = document.getElementById('camVideo');
const canvas = document.getElementById('camCanvas');
const ctx    = canvas.getContext('2d');

let rxActive=false, rxStream=null, rxInterval=null;
let rxMorseBuffer='', rxTextBuffer='';
let lightOn=false, lightOnTime=0, lightOffTime=0;
let baselineLow=999, baselineHigh=0;
let brightCalibFrames=0, brightCalibDone=false;

// Timing calibration state
let calibMode=false;          // true when running calibration listen
let calibPulses=[];           // recorded ON durations
let calibGaps=[];             // recorded OFF durations (between symbols)
let calibLastOff=0;
let calibLightOn=false;
let calibLightOnTime=0;

// Learned thresholds (ms)
let dotUnit    = 130;         // estimated dot duration
let dotDashMid = 0;           // midpoint between dot and dash durations â€” 0 = not calibrated
let symGapMid  = 0;           // midpoint between sym-gap and char-gap
let calibrated = false;

let charTimer=null, wordTimer=null;

function getBrightness() {
  ctx.drawImage(video, 0, 0, 64, 64);
  const d = ctx.getImageData(16,16,32,32).data;
  let s=0;
  for (let i=0;i<d.length;i+=4) s += d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114;
  return s/(d.length/4);
}

function getLightThreshold() {
  return baselineLow + Math.max((baselineHigh-baselineLow)*0.45, 12);
}

// â”€â”€ Calibration receive mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function toggleCalib() {
  if (!rxActive) {
    // Start camera first, then go into calib mode
    startCamera(true);
  } else if (calibMode) {
    finishCalib();
    stopCamera();
  } else {
    // camera already running for receive â€” restart in calib mode
    stopCamera();
    startCamera(true);
  }
}

async function startCamera(forCalib) {
  try {
    rxStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: 'environment' }, width:{ideal:64}, height:{ideal:64} },
      audio: false
    });
    video.srcObject = rxStream;
    await video.play().catch(()=>{});
    canvas.width=64; canvas.height=64;
    rxActive=true;
    brightCalibFrames=0; brightCalibDone=false;
    baselineLow=999; baselineHigh=0;

    if (forCalib) {
      calibMode=true; calibPulses=[]; calibGaps=[];
      calibLightOn=false; calibLastOff=0;
      document.getElementById('runCalibBtn').textContent = 'â¹ Stop Calibration';
      document.getElementById('rxStatus').textContent = 'Brightness calibrating... aim at light';
      document.getElementById('cr-status').className = 'calib-warn';
      document.getElementById('cr-status').textContent = 'â³ Listening for calibration signal...';
    } else {
      calibMode=false;
      document.getElementById('rxBtn').textContent = 'â›” Stop Receiving';
      document.getElementById('rxBtn').classList.add('recording');
      document.getElementById('rxStatus').textContent = 'Calibrating brightness...';
    }

    rxMorseBuffer=''; 
    lightOn=false; lightOffTime=0;
    rxInterval = setInterval(processFrame, 50);
  } catch(e) {
    alert('Camera access denied. Please allow camera permission.');
  }
}

function stopCamera() {
  clearInterval(rxInterval);
  clearTimeout(charTimer); clearTimeout(wordTimer);
  if (rxStream) rxStream.getTracks().forEach(t=>t.stop());
  rxStream=null; rxActive=false; calibMode=false;
  document.getElementById('rxBtn').textContent = 'ðŸ“· Start Receiving';
  document.getElementById('rxBtn').classList.remove('recording');
  document.getElementById('runCalibBtn').textContent = 'ðŸ“¶ Run Calibration';
  document.getElementById('rxStatus').textContent = 'Stopped.';
  document.getElementById('rxDot').style.background='#333';
  document.getElementById('rxDot').style.boxShadow='none';
  document.getElementById('lightMeter').style.width='0%';
}

function finishCalib() {
  // Analyse captured pulses to find dot unit and dash threshold
  if (calibPulses.length < 4) {
    document.getElementById('cr-status').className='calib-warn';
    document.getElementById('cr-status').textContent='âš  Not enough data. Try again closer/darker.';
    return;
  }

  // Sort pulses â€” short ones are dots, long ones are dashes
  const sorted = [...calibPulses].sort((a,b)=>a-b);
  const mid    = Math.floor(sorted.length/2);

  // Find natural gap in durations (k-means style: 2 clusters)
  let bestSplit=0, bestScore=-Infinity;
  for (let i=1;i<sorted.length;i++) {
    const gap = sorted[i]-sorted[i-1];
    if (gap > bestScore) { bestScore=gap; bestSplit=i; }
  }
  const dots  = sorted.slice(0, bestSplit);
  const dashes= sorted.slice(bestSplit);

  if (dots.length===0 || dashes.length===0) {
    document.getElementById('cr-status').className='calib-warn';
    document.getElementById('cr-status').textContent='âš  Could not distinguish dots from dashes. Try again.';
    return;
  }

  const avgDot  = dots.reduce((a,b)=>a+b,0)  / dots.length;
  const avgDash = dashes.reduce((a,b)=>a+b,0) / dashes.length;
  dotDashMid    = (avgDot + avgDash) / 2;
  dotUnit       = Math.round(avgDot);

  // Analyse gaps to find sym-gap vs char-gap threshold
  let symGapMidCalc = dotUnit * 2; // fallback
  if (calibGaps.length >= 4) {
    const sortedGaps = [...calibGaps].sort((a,b)=>a-b);
    let bestGapSplit=0, bestGapScore=-Infinity;
    for (let i=1;i<sortedGaps.length;i++) {
      const g = sortedGaps[i]-sortedGaps[i-1];
      if (g > bestGapScore) { bestGapScore=g; bestGapSplit=i; }
    }
    const symGaps  = sortedGaps.slice(0, bestGapSplit);
    const charGaps = sortedGaps.slice(bestGapSplit);
    if (symGaps.length>0 && charGaps.length>0) {
      const avgSym  = symGaps.reduce((a,b)=>a+b,0)/symGaps.length;
      const avgChar = charGaps.reduce((a,b)=>a+b,0)/charGaps.length;
      symGapMid = (avgSym+avgChar)/2;
      symGapMidCalc = symGapMid;
    }
  }
  symGapMid = symGapMidCalc;
  calibrated = true;

  document.getElementById('cr-dot').textContent  = `${Math.round(avgDot)}ms (avg dot)`;
  document.getElementById('cr-dash').textContent = `>${Math.round(dotDashMid)}ms = dash`;
  document.getElementById('cr-gap').textContent  = `>${Math.round(symGapMid)}ms = letter gap`;
  document.getElementById('cr-status').className = 'calib-ok';
  document.getElementById('cr-status').textContent = 'âœ… Calibrated! Ready to receive.';
}

// â”€â”€ Toggle receive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function toggleReceive() {
  if (!rxActive) {
    await startCamera(false);
  } else if (!calibMode) {
    stopCamera();
  } else {
    finishCalib();
    stopCamera();
    await startCamera(false);
  }
}

// â”€â”€ Frame processing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function processFrame() {
  let b;
  try { b=getBrightness(); } catch(e){ return; }
  const now = Date.now();

  // Brightness baseline calibration (first 30 frames)
  if (!brightCalibDone) {
    if (b<baselineLow)  baselineLow=b;
    if (b>baselineHigh) baselineHigh=b;
    brightCalibFrames++;
    if (brightCalibFrames>=30) {
      brightCalibDone=true;
      document.getElementById('rxStatus').textContent = calibMode ? 'Listening for calibration signal...' : 'Listening...';
    }
    return;
  }

  const threshold = getLightThreshold();
  if (b<threshold) baselineLow = baselineLow*0.97 + b*0.03;
  const isOn = b > threshold;

  // Light meter
  document.getElementById('lightMeter').style.width =
    Math.min(100, Math.max(0, ((b-baselineLow)/Math.max(baselineHigh-baselineLow,20))*100))+'%';

  // Flash indicator
  const dot = document.getElementById('rxDot');
  dot.style.background  = isOn ? '#ffe066' : '#333';
  dot.style.boxShadow   = isOn ? '0 0 10px #ffe066' : 'none';

  if (calibMode) {
    processCalibrateFrame(isOn, now);
  } else {
    processDecodeFrame(isOn, now);
  }
}

function processCalibrateFrame(isOn, now) {
  if (isOn && !calibLightOn) {
    calibLightOn=true;
    const offDur = calibLastOff>0 ? now-calibLastOff : 0;
    if (offDur>20 && offDur<5000) calibGaps.push(offDur);
    calibLightOnTime=now;
    document.getElementById('rxStatus').textContent = 'ðŸ”¦ Flash detected, collecting...';
  } else if (!isOn && calibLightOn) {
    calibLightOn=false;
    const onDur = now-calibLightOnTime;
    calibLastOff=now;
    if (onDur>15 && onDur<3000) {
      calibPulses.push(onDur);
      document.getElementById('rxStatus').textContent = `Pulses captured: ${calibPulses.length}`;
    }
  }
  // Auto-finish after 60 pulses
  if (calibPulses.length>=60) {
    finishCalib();
    stopCamera();
  }
}

function processDecodeFrame(isOn, now) {
  document.getElementById('rxStatus').textContent = isOn ? 'ðŸ”¦ Flash!' : 'Listening...';

  // Use calibrated thresholds or fallback to dotUnit-based estimates
  const ddMid   = dotDashMid>0 ? dotDashMid  : dotUnit*2;
  const sgMid   = symGapMid>0  ? symGapMid   : dotUnit*2;
  const wordThr = sgMid * 2.5;

  if (isOn && !lightOn) {
    lightOn=true;
    clearTimeout(charTimer); clearTimeout(wordTimer);
    const offDur = lightOffTime>0 ? now-lightOffTime : 0;
    if (offDur>wordThr)       { flushChar(); flushWord(); }
    else if (offDur>sgMid)    { flushChar(); }
    lightOnTime=now;
  } else if (!isOn && lightOn) {
    lightOn=false;
    const onDur = now-lightOnTime;
    lightOffTime=now;

    if (onDur < 15) return; // noise filter

    const sym = onDur > ddMid ? '-' : '.';
    rxMorseBuffer += sym;

    // If not calibrated, auto-learn dot unit
    if (!calibrated && sym==='.' && onDur>20) {
      dotUnit = Math.round(dotUnit*0.8 + onDur*1.2*0.2);
    }

    document.getElementById('receive-morse').textContent =
      (rxTextBuffer ? '['+rxTextBuffer.trim()+'] ' : '') + rxMorseBuffer || 'â€”';

    charTimer = setTimeout(()=>flushChar(), sgMid*1.2);
    wordTimer = setTimeout(()=>flushWord(), wordThr);
  }
}

function flushChar() {
  if (!rxMorseBuffer) return;
  rxTextBuffer += MORSE_REV[rxMorseBuffer] || '?';
  document.getElementById('receive-output').textContent = rxTextBuffer.trim()||'â€”';
  rxMorseBuffer='';
  document.getElementById('receive-morse').textContent='â€”';
}
function flushWord() {
  flushChar();
  rxTextBuffer+=' ';
  document.getElementById('receive-output').textContent = rxTextBuffer.trim()||'â€”';
}
function clearReceived() {
  clearTimeout(charTimer); clearTimeout(wordTimer);
  rxMorseBuffer=''; rxTextBuffer='';
  document.getElementById('receive-morse').textContent='â€”';
  document.getElementById('receive-output').textContent='â€”';
  if (!calibrated) { dotUnit=130; dotDashMid=0; symGapMid=0; }
  brightCalibDone=false; brightCalibFrames=0;
  baselineLow=999; baselineHigh=0;
  if (rxActive) document.getElementById('rxStatus').textContent='Recalibrating brightness...';
}

function switchTab(tab) {
  document.querySelectorAll('.tab').forEach((t,i)=>
    t.classList.toggle('active',['send','receive','ref'][i]===tab));
  document.querySelectorAll('.panel').forEach(p=>p.classList.remove('active'));
  document.getElementById('panel-'+tab).classList.add('active');
}
</script>
</body>
</html>
